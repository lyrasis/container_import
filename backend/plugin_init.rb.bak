require 'csv'
require 'jsonmodel'

$stdout.puts "\n\n\n\n#---:Container Importer:---#\n\n\n\n"
# resource  series  box barcode location  coordinate
container_csv_path = "/tmp/aspace/container.csv"
status_file        = File.open("/tmp/aspace/status.txt", 'w')
error_file         = File.open("/tmp/aspace/error.txt", 'w')

# container in instance obj
def build_container(box, barcode)
  {
    "instance_type" => "mixed_materials",
    "jsonmodel_type"=> "instance",
    "container"     => {
      "barcode_1"=> barcode,
      "indicator_1" => box,
      "type_1"=> "box",
      "jsonmodel_type"=>"container",
      "container_locations"=> []
    }
  }
end

def find_children_by_parent_id(parent_id, repo_id, resource_id)
  child_ids = []
  DB.open do |db|
    child_ids = db[:archival_object].where(
      parent_id: parent_id,
      repo_id: repo_id,
      root_record_id: resource_id,
    ).select(:id).map(:id)
  end  
  child_ids
end

# using series number in csv attempt to match it to a component id
def find_series(repo_id, resource_id, series)
  series_id = nil
  DB.open do |db|
    db[:archival_object].where(
      parent_id: nil,
      repo_id: repo_id,
      root_record_id: resource_id,
    ).select(:id, :component_id).each do |ao|
      unless ao[:component_id].nil?
        id = ao[:component_id].match(/(\d+)/)[0] rescue nil
        if id && id == series
          series_id = ao[:id]
          break
        end
      end
    end
  end
  series_id
end

def growl(file, msg)
  file.puts msg
  $stderr.puts msg
end

# normalize aspace identifier json and mit csv identifier for equality
def parse_identifier(identifier)
  prefix = identifier.match(/^(A|M)C/)[0] rescue nil
  number = identifier.match(/\d{1,}/)[0].to_i.to_s rescue nil
  parsed = (prefix and number) ? "#{prefix}#{number}" : identifier
  parsed
end

# resources hash with { parsed_identifier: { id: x, repo_id: y } ... }
def parsed_resources
  resources = Hash.new { |hash, key| hash[key] = {} }
  DB.open do |db|
    db[:resource].select(:id, :identifier, :repo_id).each do |resource|
      json_identifier   = JSON.parse(resource[:identifier]).join
      parsed_identifier = parse_identifier(json_identifier)
      resources[parsed_identifier] = { id: resource[:id], repo_id: resource[:repo_id] }
    end
  end
  resources
end

def report(file, msg)
  file.puts msg
  $stdout.puts msg
end

ArchivesSpaceService.loaded_hook do
  resources = parsed_resources

  CSV.foreach(container_csv_path, headers: true) do |row|
    data            = row.to_hash
    data["barcode"] = data["barcode"].nil? ? nil : data["barcode"].gsub(/\D/, '')
    
    resource   = data["resource"]
    parsed     = parse_identifier(resource)
    series     = data["series"]
    box        = data["box"]
    barcode    = data["barcode"]
    location   = data["location"]
    coordinate = data["coordinate"]

    unless resources.has_key?(parsed)
      growl error_file, "Skipping \"#{resource}:#{parsed}\" resource not found in ArchivesSpace!"
      next
    end

    unless box && barcode
      growl error_file, "Skipping \"#{resource}:#{parsed}\" box and barcode values are required!"
      next
    end

    report status_file, "Row data: #{data}"

    repo_id     = resources[parsed][:repo_id]
    resource_id = resources[parsed][:id]

    RequestContext.open(:repo_id => repo_id, current_username: "admin") do
      r     = Resource.get_or_die resource_id
      r_obj = Resource.to_jsonmodel(resource_id)
      # puts r.inspect
      # puts r_obj.inspect

      if series
        series_id = find_series(repo_id, resource_id, series)
        if series_id
          report status_file, "Found series #{series} for resource #{resource}"
          found_box = false
          ao        = ArchivalObject.get_or_die(series_id)
          ao_obj    = ArchivalObject.to_jsonmodel(series_id)
          # puts ao.inspect
          # puts ao_obj.inspect

          # check direct children of series for container (box)
          child_ids = find_children_by_parent_id(series_id, repo_id, resource_id)
          child_ids.each do |child_id|
            child_ao  = ArchivalObject.get_or_die(child_id)
            child_obj = ArchivalObject.to_jsonmodel(child_id)
            child_obj["instances"].each do |i|
              if i.has_key?("container") && i["container"]["type_1"] == "box" && i["container"]["indicator_1"] == box
                found_box = true
                i["container"]["barcode_1"] = barcode
                child_ao.update_from_json(JSONModel(:archival_object).from_hash(child_obj.to_hash))
                report status_file, "Updated barcode for resource #{resource}, series #{series}, box #{box} to #{barcode}"
              end
            end
          end

          # if no container matches then create container assoc with series
          unless found_box
            report status_file, "Did not find box for #{resource} series #{series_id} with indicator #{box}"
            # TODO: if not found create container instance assoc with series
            # ao.update_from_json(JSONModel(:archival_object).from_hash(ao_obj.to_hash))
          end
        else
          # series was not found so create series level component with container
          report status_file, "Did not find series #{series} for resource #{resource}"
          # TODO: create series
          # TODO: create container
        end
      else
        # no series provided in csv so create container associated with resource
        r_obj["instances"] << build_container(box, barcode)
        puts r_obj.inspect
        # r.update_from_json(JSONModel(:resource).from_hash(r_obj.to_hash))
        report status_file, "Created container for resource #{resource} from #{data}"
      end
    end
    report status_file, "-----"
    break
  end
end

status_file.close
error_file.close